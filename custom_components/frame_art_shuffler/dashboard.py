"""Dashboard generator for Frame Art Shuffler integration.

This module generates a dynamic Lovelace dashboard YAML file based on
registered Frame Art devices and their entities.
"""
from __future__ import annotations

import logging
from pathlib import Path
from typing import Any

import yaml

_LOGGER = logging.getLogger(__name__)

# Header comment for generated dashboard
DASHBOARD_HEADER = """\
# ============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT
# ============================================================================
# This dashboard is automatically generated by the Frame Art Shuffler
# integration. Any manual changes will be overwritten on the next restart.
#
# To customize, create your own dashboard and use these entities as reference.
# ============================================================================

"""


def generate_dashboard(
    hass: Any,
    entry: Any,
    output_path: Path,
) -> bool:
    """Generate the Lovelace dashboard YAML file.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        output_path: Path to write the YAML file
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    try:
        from homeassistant.helpers import device_registry as dr
        from homeassistant.helpers import entity_registry as er
        from .const import DOMAIN
        from .config_entry import list_tv_configs
    except ImportError:
        _LOGGER.error("Cannot generate dashboard: Home Assistant not available")
        return False

    device_registry = dr.async_get(hass)
    entity_registry = er.async_get(hass)

    # Get all TV configs from the entry
    tv_configs = list_tv_configs(entry)
    
    if not tv_configs:
        _LOGGER.info("No TVs configured, skipping dashboard generation")
        return False

    # Build the dashboard structure
    dashboard = _build_dashboard(
        hass,
        entry,
        tv_configs,
        device_registry,
        entity_registry,
    )

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write the YAML file
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(DASHBOARD_HEADER)
            yaml.dump(dashboard, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
        _LOGGER.info(f"Dashboard generated successfully at {output_path}")
        return True
    except OSError as err:
        _LOGGER.error(f"Failed to write dashboard file: {err}")
        return False


def _build_dashboard(
    hass: Any,
    entry: Any,
    tv_configs: dict[str, dict[str, Any]],
    device_registry: Any,
    entity_registry: Any,
) -> dict[str, Any]:
    """Build the complete dashboard configuration."""
    from .const import DOMAIN
    
    # Build cards for each TV
    tv_cards = []
    for tv_id, tv_config in tv_configs.items():
        tv_name = tv_config.get("name", tv_id)
        card = _build_tv_card(hass, entry, tv_id, tv_name, entity_registry)
        if card:
            tv_cards.append(card)

    # Wrap in grid layout if more than one TV
    if len(tv_cards) > 1:
        # Use a grid with 2 columns for multiple TVs
        content_card = {
            "type": "grid",
            "columns": 2,
            "square": False,
            "cards": tv_cards,
        }
    elif len(tv_cards) == 1:
        content_card = tv_cards[0]
    else:
        content_card = {
            "type": "markdown",
            "content": "No Frame Art TVs configured. Add a TV through the integration settings.",
        }

    # Build the view
    view = {
        "title": "Frame Art Shuffler",
        "path": "frame-art-shuffler",
        "icon": "mdi:television-ambient-light",
        "cards": [content_card] if not isinstance(content_card, list) else content_card,
    }

    # Build complete dashboard
    dashboard = {
        "title": "Frame Art Shuffler: TV Management",
        "views": [view],
    }

    return dashboard


def _build_tv_card(
    hass: Any,
    entry: Any,
    tv_id: str,
    tv_name: str,
    entity_registry: Any,
) -> dict[str, Any] | None:
    """Build a card for a single TV with all its sections."""
    from .const import DOMAIN
    
    # Find all entities for this TV
    entities = _get_tv_entities(entry.entry_id, tv_id, entity_registry)
    
    if not entities:
        return None

    # Build the vertical stack with sections
    cards = []

    # === Header with TV name ===
    cards.append({
        "type": "markdown",
        "content": f"## ðŸ“º {tv_name}",
    })

    # === Status Section ===
    status_card = _build_status_section(entities)
    if status_card:
        cards.append(status_card)

    # === Current Image Section ===
    image_card = _build_image_section(entities)
    if image_card:
        cards.append(image_card)

    # === Brightness Control Section ===
    brightness_card = _build_brightness_section(entities)
    if brightness_card:
        cards.append(brightness_card)

    # === Auto-Brightness Section ===
    auto_bright_card = _build_auto_brightness_section(entities)
    if auto_bright_card:
        cards.append(auto_bright_card)

    # === Auto-Motion Section ===
    auto_motion_card = _build_auto_motion_section(entities)
    if auto_motion_card:
        cards.append(auto_motion_card)

    # === Recent Activity Section (at bottom) ===
    activity_card = _build_activity_section(entities)
    if activity_card:
        cards.append(activity_card)

    # Wrap everything in a vertical stack
    return {
        "type": "vertical-stack",
        "cards": cards,
    }


def _get_tv_entities(
    entry_id: str,
    tv_id: str,
    entity_registry: Any,
) -> dict[str, str]:
    """Get all entity IDs for a specific TV.
    
    Returns a dict mapping entity key to entity_id.
    """
    from .const import DOMAIN
    
    entities = {}
    
    # Entity unique_id patterns to look for
    patterns = {
        # Binary sensors
        "screen_on": f"{entry_id}_{tv_id}_screen_on",
        "art_mode": f"{entry_id}_{tv_id}_art_mode",
        # Sensors
        "current_artwork": f"{entry_id}_{tv_id}",
        "last_shuffle_image": f"{entry_id}_{tv_id}_last_shuffle_image",
        "last_shuffle_timestamp": f"{entry_id}_{tv_id}_last_shuffle_timestamp",
        "ip_address": f"{entry_id}_{tv_id}_ip",
        "mac_address": f"{entry_id}_{tv_id}_mac",
        "motion_sensor": f"{entry_id}_{tv_id}_motion_sensor",
        "light_sensor": f"{entry_id}_{tv_id}_light_sensor",
        "auto_bright_last": f"{entry_id}_{tv_id}_auto_bright_last",
        "auto_bright_next": f"{entry_id}_{tv_id}_auto_bright_next",
        "auto_bright_target": f"{entry_id}_{tv_id}_auto_bright_target",
        "auto_bright_sensor_lux": f"{entry_id}_{tv_id}_auto_bright_sensor_lux",
        "auto_motion_last": f"{entry_id}_{tv_id}_auto_motion_last",
        "auto_motion_off_at": f"{entry_id}_{tv_id}_auto_motion_off_at",
        "recent_activity": f"{entry_id}_{tv_id}_recent_activity",
        # Numbers
        "shuffle_frequency": f"{tv_id}_shuffle_frequency",
        "brightness": f"{tv_id}_brightness",
        "min_lux": f"{tv_id}_min_lux",
        "max_lux": f"{tv_id}_max_lux",
        "min_brightness": f"{tv_id}_min_auto_brightness",
        "max_brightness": f"{tv_id}_max_auto_brightness",
        "motion_off_delay": f"{tv_id}_motion_off_delay",
        # Switches
        "dynamic_brightness": f"{tv_id}_dynamic_brightness",
        "motion_control": f"{tv_id}_motion_control",
        # Buttons
        "tv_on": f"{tv_id}_tv_on",
        "tv_off": f"{tv_id}_tv_off",
        "art_mode_button": f"{tv_id}_art_mode",
        "on_art_mode": f"{tv_id}_on_art_mode",
        "shuffle": f"{tv_id}_shuffle",
        "clear_token": f"{tv_id}_clear_token",
        "calibrate_dark": f"{tv_id}_calibrate_dark",
        "calibrate_bright": f"{tv_id}_calibrate_bright",
        "trigger_brightness": f"{tv_id}_trigger_brightness",
        "trigger_motion_off": f"{tv_id}_trigger_motion_off",
    }
    
    # Look up each entity
    for key, unique_id in patterns.items():
        entity_entry = entity_registry.async_get_entity_id(
            _get_platform_for_key(key),
            DOMAIN,
            unique_id,
        )
        if entity_entry:
            entities[key] = entity_entry
    
    return entities


def _get_platform_for_key(key: str) -> str:
    """Get the platform (domain) for an entity key."""
    binary_sensors = {"screen_on", "art_mode"}
    sensors = {
        "current_artwork", "last_shuffle_image", "last_shuffle_timestamp",
        "ip_address", "mac_address", "motion_sensor", "light_sensor",
        "auto_bright_last", "auto_bright_next", "auto_bright_target",
        "auto_bright_sensor_lux", "auto_motion_last", "auto_motion_off_at",
        "recent_activity",
    }
    numbers = {
        "shuffle_frequency", "brightness", "min_lux", "max_lux",
        "min_brightness", "max_brightness", "motion_off_delay",
    }
    switches = {"dynamic_brightness", "motion_control"}
    buttons = {
        "tv_on", "tv_off", "art_mode_button", "on_art_mode", "shuffle",
        "clear_token", "calibrate_dark", "calibrate_bright",
        "trigger_brightness", "trigger_motion_off",
    }
    
    if key in binary_sensors:
        return "binary_sensor"
    elif key in sensors:
        return "sensor"
    elif key in numbers:
        return "number"
    elif key in switches:
        return "switch"
    elif key in buttons:
        return "button"
    return "sensor"


def _build_status_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the status section showing on/off and art mode."""
    status_entities = []
    
    # Screen on/off status
    if "screen_on" in entities:
        status_entities.append({
            "entity": entities["screen_on"],
            "name": "Screen",
        })
    
    # Art mode status
    if "art_mode" in entities:
        status_entities.append({
            "entity": entities["art_mode"],
            "name": "Art Mode",
        })
    
    # Power control buttons
    button_entities = []
    if "tv_on" in entities:
        button_entities.append({
            "entity": entities["tv_on"],
        })
    if "tv_off" in entities:
        button_entities.append({
            "entity": entities["tv_off"],
        })
    if "art_mode_button" in entities:
        button_entities.append({
            "entity": entities["art_mode_button"],
        })
    if "on_art_mode" in entities:
        button_entities.append({
            "entity": entities["on_art_mode"],
        })
    
    if not status_entities and not button_entities:
        return None
    
    cards = []
    
    if status_entities:
        cards.append({
            "type": "entities",
            "title": "Status",
            "entities": status_entities,
        })
    
    if button_entities:
        cards.append({
            "type": "entities",
            "title": "Power Controls",
            "entities": button_entities,
        })
    
    return {
        "type": "vertical-stack",
        "cards": cards,
    }


def _build_image_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the current image section."""
    image_entities = []
    
    if "current_artwork" in entities:
        image_entities.append({
            "entity": entities["current_artwork"],
            "name": "Current Image",
        })
    
    if "shuffle" in entities:
        image_entities.append({
            "entity": entities["shuffle"],
        })
    
    if "shuffle_frequency" in entities:
        image_entities.append({
            "entity": entities["shuffle_frequency"],
            "name": "Shuffle Frequency",
        })
    
    if "last_shuffle_timestamp" in entities:
        image_entities.append({
            "entity": entities["last_shuffle_timestamp"],
            "name": "Last Shuffle",
        })
    
    if not image_entities:
        return None
    
    return {
        "type": "entities",
        "title": "ðŸŽ¨ Current Artwork",
        "entities": image_entities,
    }


def _build_brightness_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the manual brightness control section."""
    if "brightness" not in entities:
        return None
    
    return {
        "type": "entities",
        "title": "ðŸ’¡ Brightness",
        "entities": [
            {
                "entity": entities["brightness"],
                "name": "Brightness Level",
            },
        ],
    }


def _build_auto_brightness_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the auto-brightness management section."""
    section_entities = []
    
    # Enable/disable switch
    if "dynamic_brightness" in entities:
        section_entities.append({
            "entity": entities["dynamic_brightness"],
            "name": "Auto-Bright Enable",
        })
    
    # Trigger button
    if "trigger_brightness" in entities:
        section_entities.append({
            "entity": entities["trigger_brightness"],
        })
    
    # Status sensors
    if "auto_bright_sensor_lux" in entities:
        section_entities.append({
            "entity": entities["auto_bright_sensor_lux"],
            "name": "Current Lux",
        })
    
    if "auto_bright_target" in entities:
        section_entities.append({
            "entity": entities["auto_bright_target"],
            "name": "Target Brightness",
        })
    
    if "auto_bright_next" in entities:
        section_entities.append({
            "entity": entities["auto_bright_next"],
            "name": "Next Adjustment",
        })
    
    if "auto_bright_last" in entities:
        section_entities.append({
            "entity": entities["auto_bright_last"],
            "name": "Last Adjustment",
        })
    
    # Configuration entities
    config_entities = []
    
    if "min_lux" in entities:
        config_entities.append({
            "entity": entities["min_lux"],
            "name": "Min Lux (Dark)",
        })
    
    if "max_lux" in entities:
        config_entities.append({
            "entity": entities["max_lux"],
            "name": "Max Lux (Bright)",
        })
    
    if "min_brightness" in entities:
        config_entities.append({
            "entity": entities["min_brightness"],
            "name": "Min Level",
        })
    
    if "max_brightness" in entities:
        config_entities.append({
            "entity": entities["max_brightness"],
            "name": "Max Level",
        })
    
    # Calibration buttons
    if "calibrate_dark" in entities:
        config_entities.append({
            "entity": entities["calibrate_dark"],
        })
    
    if "calibrate_bright" in entities:
        config_entities.append({
            "entity": entities["calibrate_bright"],
        })
    
    if not section_entities and not config_entities:
        return None
    
    cards = []
    
    if section_entities:
        cards.append({
            "type": "entities",
            "title": "â˜€ï¸ Auto-Brightness",
            "entities": section_entities,
        })
    
    if config_entities:
        cards.append({
            "type": "entities",
            "title": "Auto-Brightness Configuration",
            "entities": config_entities,
            "state_color": False,
        })
    
    return {
        "type": "vertical-stack",
        "cards": cards,
    }


def _build_auto_motion_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the auto-motion management section."""
    section_entities = []
    
    # Enable/disable switch
    if "motion_control" in entities:
        section_entities.append({
            "entity": entities["motion_control"],
            "name": "Auto-Motion Enable",
        })
    
    # Trigger off button
    if "trigger_motion_off" in entities:
        section_entities.append({
            "entity": entities["trigger_motion_off"],
        })
    
    # Motion off delay config
    if "motion_off_delay" in entities:
        section_entities.append({
            "entity": entities["motion_off_delay"],
            "name": "Off Delay",
        })
    
    # Status sensors
    if "auto_motion_off_at" in entities:
        section_entities.append({
            "entity": entities["auto_motion_off_at"],
            "name": "Turning Off At",
        })
    
    if "auto_motion_last" in entities:
        section_entities.append({
            "entity": entities["auto_motion_last"],
            "name": "Last Motion",
        })
    
    # Associated motion sensor
    if "motion_sensor" in entities:
        section_entities.append({
            "entity": entities["motion_sensor"],
            "name": "Motion Sensor",
        })
    
    if not section_entities:
        return None
    
    return {
        "type": "entities",
        "title": "ðŸš¶ Auto-Motion",
        "entities": section_entities,
    }


def _build_activity_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the recent activity section using a markdown card with template.
    
    This creates a markdown card that displays the formatted history from
    the activity sensor's attributes.
    """
    if "recent_activity" not in entities:
        return None
    
    activity_entity = entities["recent_activity"]
    
    # Build a markdown template that renders the history nicely
    # The template iterates over the formatted_history attribute
    template_content = f"""## ðŸ“‹ Recent Activity

{{% set history = state_attr('{activity_entity}', 'formatted_history') or [] %}}
{{% if history | length == 0 %}}
_No activity recorded yet_
{{% else %}}
{{% for event in history[:20] %}}
**{{{{ event.time }}}}** - {{{{ event.message }}}}
{{% endfor %}}
{{% endif %}}"""
    
    return {
        "type": "markdown",
        "content": template_content,
    }


async def async_generate_dashboard(hass: Any, entry: Any) -> bool:
    """Async wrapper for dashboard generation.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    from pathlib import Path
    
    # Output path for the dashboard
    output_path = Path(__file__).parent / "dashboards" / "frame_art.yaml"
    
    # Run the generation in the executor since it does file I/O
    result = await hass.async_add_executor_job(
        generate_dashboard,
        hass,
        entry,
        output_path,
    )
    
    return result
