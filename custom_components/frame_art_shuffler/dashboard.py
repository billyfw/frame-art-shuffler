"""Dashboard generator for Frame Art Shuffler integration.

This module generates a dynamic Lovelace dashboard YAML file based on
registered Frame Art devices and their entities.
"""
from __future__ import annotations

import logging
from pathlib import Path
from typing import Any

import yaml

_LOGGER = logging.getLogger(__name__)

# Header comment for generated dashboard
DASHBOARD_HEADER = """\
# ============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT
# ============================================================================
# This dashboard is automatically generated by the Frame Art Shuffler
# integration. Any manual changes will be overwritten on the next restart.
#
# To customize, create your own dashboard and use these entities as reference.
#
# DEPENDENCY: This dashboard requires the 'layout-card' custom card for
# responsive mobile layout. Install via HACS:
#   https://github.com/thomasloven/lovelace-layout-card
# ============================================================================

"""


def generate_dashboard(
    hass: Any,
    entry: Any,
    output_path: Path,
) -> bool:
    """Generate the Lovelace dashboard YAML file.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        output_path: Path to write the YAML file
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    try:
        from homeassistant.helpers import device_registry as dr
        from homeassistant.helpers import entity_registry as er
        from .const import DOMAIN
        from .config_entry import list_tv_configs
    except ImportError:
        _LOGGER.error("Cannot generate dashboard: Home Assistant not available")
        return False

    device_registry = dr.async_get(hass)
    entity_registry = er.async_get(hass)

    # Get all TV configs from the entry
    tv_configs = list_tv_configs(entry)
    
    if not tv_configs:
        _LOGGER.info("No TVs configured, skipping dashboard generation")
        return False

    # Build the dashboard structure
    dashboard = _build_dashboard(
        hass,
        entry,
        tv_configs,
        device_registry,
        entity_registry,
    )

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write the YAML file
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(DASHBOARD_HEADER)
            yaml.dump(dashboard, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
        _LOGGER.info(f"Dashboard generated successfully at {output_path}")
        return True
    except OSError as err:
        _LOGGER.error(f"Failed to write dashboard file: {err}")
        return False


def _build_dashboard(
    hass: Any,
    entry: Any,
    tv_configs: dict[str, dict[str, Any]],
    device_registry: Any,
    entity_registry: Any,
) -> dict[str, Any]:
    """Build the complete dashboard configuration.
    
    Each TV gets its own tab (view) in the dashboard.
    """
    from .const import DOMAIN
    
    views = []
    
    # Build a view (tab) for each TV
    for tv_id, tv_config in tv_configs.items():
        tv_name = tv_config.get("name", tv_id)
        # Use short_name for tab title, or first 3 chars of name if not set
        short_name = tv_config.get("short_name", "").strip()
        tab_title = short_name if short_name else tv_name[:3]
        view = _build_tv_view(hass, entry, tv_id, tv_name, tab_title, entity_registry)
        if view:
            views.append(view)
    
    # If no TVs configured, show a placeholder view
    if not views:
        views.append({
            "title": "Frame TV Manager",
            "path": "frame-tv-manager",
            "icon": "mdi:television-ambient-light",
            "cards": [{
                "type": "markdown",
                "content": "No Frame Art TVs configured. Add a TV through the integration settings.",
            }],
        })

    # Add Settings tab as the rightmost view
    settings_view = _build_settings_view(hass, entry)
    views.append(settings_view)

    # Build complete dashboard
    dashboard = {
        "title": "Frame TV Manager",
        "views": views,
    }

    return dashboard


def _build_settings_view(hass: Any, entry: Any) -> dict[str, Any]:
    """Build the settings view (tab) showing logging status and configuration."""
    from .const import (
        CONF_LOGGING_ENABLED,
        CONF_LOG_RETENTION_MONTHS,
        CONF_LOG_FLUSH_MINUTES,
        DEFAULT_LOGGING_ENABLED,
        DEFAULT_LOG_RETENTION_MONTHS,
        DEFAULT_LOG_FLUSH_MINUTES,
        LOG_STORAGE_RELATIVE_PATH,
        LOG_SUMMARY_FILENAME,
    )
    
    # Get current logging settings from entry options
    options = entry.options or {}
    logging_enabled = options.get(CONF_LOGGING_ENABLED, DEFAULT_LOGGING_ENABLED)
    retention_months = options.get(CONF_LOG_RETENTION_MONTHS, DEFAULT_LOG_RETENTION_MONTHS)
    flush_minutes = options.get(CONF_LOG_FLUSH_MINUTES, DEFAULT_LOG_FLUSH_MINUTES)
    
    # Build path to summary file for template
    summary_path = f"/config/{LOG_STORAGE_RELATIVE_PATH}/{LOG_SUMMARY_FILENAME}"
    
    cards = []
    
    # Logging Status card
    status_icon = "✅" if logging_enabled else "❌"
    status_text = "Enabled" if logging_enabled else "Disabled"
    
    logging_status_md = f"""## Display Logging

**Status:** {status_icon} {status_text}
**Retention:** {retention_months} months
**Flush Interval:** {flush_minutes} minutes

---

To change these settings, go to:
**Settings → Devices & Services → Frame Art Shuffler → Configure → Logging settings**
"""
    
    cards.append({
        "type": "markdown",
        "content": logging_status_md,
    })
    
    # Summary stats card (reads from summary.json via template)
    # This uses a template sensor approach - the data comes from the file
    summary_template = """## Activity Summary

{% set summary_sensor = 'sensor.frame_art_log_summary' %}
{% if states(summary_sensor) == 'unknown' or states(summary_sensor) == 'unavailable' %}
_No activity data yet. Summary will appear after the first flush cycle._
{% else %}
{% set totals = state_attr(summary_sensor, 'totals') or {} %}
{% set generated = state_attr(summary_sensor, 'generated_at') or 'Never' %}
**Total Tracked Time:** {{ (totals.get('tracked_seconds', 0) / 3600) | round(1) }} hours
**Total Events:** {{ totals.get('event_count', 0) }}
**Last Updated:** {{ generated }}

---

### By TV
{% set tvs = state_attr(summary_sensor, 'tvs') or {} %}
{% if tvs %}
{% for tv_id, tv_data in tvs.items() %}
- **{{ tv_data.get('name', tv_id) }}**: {{ (tv_data.get('total_display_seconds', 0) / 3600) | round(1) }}h ({{ tv_data.get('share_of_tracked', 0) }}%)
{% endfor %}
{% else %}
_No TV data yet_
{% endif %}

---

### Top Tags
{% set tags = state_attr(summary_sensor, 'tags') or {} %}
{% if tags %}
{% for tag, tag_data in (tags.items() | list)[:10] %}
- **{{ tag }}**: {{ (tag_data.get('total_display_seconds', 0) / 3600) | round(1) }}h
{% endfor %}
{% else %}
_No tag data yet_
{% endif %}
{% endif %}
"""
    
    cards.append({
        "type": "markdown",
        "content": summary_template,
    })

    # Clear logs button with confirmation
    cards.append({
        "type": "button",
        "name": "Clear All Frame Art Shuffler Logs",
        "icon": "mdi:delete-forever",
        "icon_height": "40px",
        "tap_action": {
            "action": "call-service",
            "service": "frame_art_shuffler.clear_display_log",
            "confirmation": {
                "text": "Are you sure you want to permanently delete all display log data? This cannot be undone.",
            },
        },
    })

    return {
        "title": "Settings",
        "path": "settings",
        "icon": "mdi:cog",
        "cards": [{
            "type": "vertical-stack",
            "cards": cards,
        }],
    }


def _build_tv_view(
    hass: Any,
    entry: Any,
    tv_id: str,
    tv_name: str,
    tab_title: str,
    entity_registry: Any,
) -> dict[str, Any] | None:
    """Build a view (tab) for a single TV with two-column layout."""
    from .const import DOMAIN
    
    # Find all entities for this TV
    entities = _get_tv_entities(entry.entry_id, tv_id, entity_registry)
    
    if not entities:
        return None

    # === COLUMN 1: Artwork ===
    col1_cards = []
    
    # Combined Current Artwork (image + details)
    artwork_card = _build_artwork_section(entities)
    if artwork_card:
        col1_cards.append(artwork_card)
    
    col1 = {
        "type": "vertical-stack",
        "cards": col1_cards,
    } if col1_cards else None

    # === COLUMN 2: Power Controls, Motion, Brightness ===
    col2_cards = []
    
    # Power Controls
    power_card = _build_power_controls_section(entities)
    if power_card:
        col2_cards.append(power_card)
    
    # Motion
    auto_motion_card = _build_auto_motion_section(entities)
    if auto_motion_card:
        col2_cards.append(auto_motion_card)
    
    # Combined Brightness (manual + auto)
    brightness_card = _build_combined_brightness_section(entities)
    if brightness_card:
        col2_cards.append(brightness_card)
    
    col2 = {
        "type": "vertical-stack",
        "cards": col2_cards,
    } if col2_cards else None

    # === COLUMN 3: Recent Activity ===
    col3_cards = []

    # Recent Activity
    activity_card = _build_activity_section(entities)
    if activity_card:
        col3_cards.append(activity_card)

    col3 = {
        "type": "vertical-stack",
        "cards": col3_cards,
    } if col3_cards else None

    # Build the responsive grid using layout-card
    # This provides 3 columns on desktop, 1 column on mobile (<800px)
    grid_cards = [c for c in [col1, col2, col3] if c]
    
    # Use layout-card for responsive columns
    all_cards = []
    
    if len(grid_cards) > 1:
        # Use layout-card with CSS grid and media queries for responsiveness
        all_cards.append({
            "type": "custom:layout-card",
            "layout_type": "custom:grid-layout",
            "layout": {
                "grid-template-columns": "1fr 1fr 1fr",
                "grid-gap": "16px",
                "mediaquery": {
                    "(max-width: 800px)": {
                        "grid-template-columns": "1fr",
                    },
                },
            },
            "cards": grid_cards,
        })
    elif grid_cards:
        all_cards.extend(grid_cards)

    # Wrap everything in a vertical-stack to enforce top-to-bottom layout
    view_cards = [{
        "type": "vertical-stack",
        "cards": all_cards,
    }] if all_cards else []

    # Create a safe path from TV name
    safe_path = tv_id.lower().replace(" ", "-").replace("_", "-")
    
    return {
        "title": tab_title,
        "path": safe_path,
        "panel": True,  # Full width layout instead of centered masonry
        "cards": view_cards,
    }


# _build_tv_card removed - replaced by _build_tv_view which creates a full view per TV


def _get_tv_entities(
    entry_id: str,
    tv_id: str,
    entity_registry: Any,
) -> dict[str, str]:
    """Get all entity IDs for a specific TV.
    
    Returns a dict mapping entity key to entity_id.
    """
    from .const import DOMAIN
    
    entities = {}
    
    # Entity unique_id patterns to look for
    patterns = {
        # Binary sensors
        "screen_on": f"{entry_id}_{tv_id}_screen_on",
        # Sensors
        "current_artwork": f"{entry_id}_{tv_id}",
        "last_shuffle_image": f"{entry_id}_{tv_id}_last_shuffle_image",
        "last_shuffle_timestamp": f"{entry_id}_{tv_id}_last_shuffle_timestamp",
        "auto_shuffle_next": f"{entry_id}_{tv_id}_auto_shuffle_next",
        "ip_address": f"{entry_id}_{tv_id}_ip",
        "mac_address": f"{entry_id}_{tv_id}_mac",
        "motion_sensor": f"{entry_id}_{tv_id}_motion_sensor",
        "light_sensor": f"{entry_id}_{tv_id}_light_sensor",
        "auto_bright_last": f"{entry_id}_{tv_id}_auto_bright_last",
        "auto_bright_next": f"{entry_id}_{tv_id}_auto_bright_next",
        "auto_bright_target": f"{entry_id}_{tv_id}_auto_bright_target",
        "auto_bright_sensor_lux": f"{entry_id}_{tv_id}_auto_bright_sensor_lux",
        "auto_motion_last": f"{entry_id}_{tv_id}_auto_motion_last",
        "auto_motion_off_at": f"{entry_id}_{tv_id}_auto_motion_off_at",
        "recent_activity": f"{entry_id}_{tv_id}_recent_activity",
        "current_matte": f"{entry_id}_{tv_id}_current_matte",
        "current_filter": f"{entry_id}_{tv_id}_current_filter",
        "matte_filter": f"{entry_id}_{tv_id}_matte_filter",
        "tags_combined": f"{entry_id}_{tv_id}_tags_combined",
        "matching_image_count": f"{entry_id}_{tv_id}_matching_image_count",
        # Numbers
        "shuffle_frequency": f"{tv_id}_shuffle_frequency",
        "brightness": f"{tv_id}_brightness",
        "min_lux": f"{tv_id}_min_lux",
        "max_lux": f"{tv_id}_max_lux",
        "min_brightness": f"{tv_id}_min_auto_brightness",
        "max_brightness": f"{tv_id}_max_auto_brightness",
        "motion_off_delay": f"{tv_id}_motion_off_delay",
        # Switches
        "power": f"{tv_id}_power",
        "dynamic_brightness": f"{tv_id}_dynamic_brightness",
        "motion_control": f"{tv_id}_motion_control",
        "verbose_motion_logging": f"{tv_id}_verbose_motion_logging",
        "auto_shuffle_switch": f"{tv_id}_auto_shuffle",
        # Buttons
        "art_mode_button": f"{tv_id}_art_mode",
        "on_art_mode": f"{tv_id}_on_art_mode",
        "shuffle": f"{tv_id}_shuffle",
        "clear_token": f"{tv_id}_clear_token",
        "calibrate_dark": f"{tv_id}_calibrate_dark",
        "calibrate_bright": f"{tv_id}_calibrate_bright",
        "trigger_brightness": f"{tv_id}_trigger_brightness",
        "trigger_motion_off": f"{tv_id}_trigger_motion_off",
    }
    
    # Look up each entity
    for key, unique_id in patterns.items():
        entity_entry = entity_registry.async_get_entity_id(
            _get_platform_for_key(key),
            DOMAIN,
            unique_id,
        )
        if entity_entry:
            entities[key] = entity_entry
    
    return entities


def _get_platform_for_key(key: str) -> str:
    """Get the platform (domain) for an entity key."""
    binary_sensors = {"screen_on"}
    sensors = {
        "current_artwork", "last_shuffle_image", "last_shuffle_timestamp",
        "auto_shuffle_next",
        "ip_address", "mac_address", "motion_sensor", "light_sensor",
        "auto_bright_last", "auto_bright_next", "auto_bright_target",
        "auto_bright_sensor_lux", "auto_motion_last", "auto_motion_off_at",
        "recent_activity", "current_matte", "current_filter",
        "matte_filter", "tags_combined", "matching_image_count",
    }
    numbers = {
        "shuffle_frequency", "brightness", "min_lux", "max_lux",
        "min_brightness", "max_brightness", "motion_off_delay",
    }
    switches = {"power", "dynamic_brightness", "motion_control", "auto_shuffle_switch"}
    buttons = {
        "tv_on", "tv_off", "art_mode_button", "on_art_mode", "shuffle",
        "clear_token", "calibrate_dark", "calibrate_bright",
        "trigger_brightness", "trigger_motion_off",
    }
    
    if key in binary_sensors:
        return "binary_sensor"
    elif key in sensors:
        return "sensor"
    elif key in numbers:
        return "number"
    elif key in switches:
        return "switch"
    elif key in buttons:
        return "button"
    return "sensor"


def _build_power_controls_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the power controls section."""
    button_entities = []
    # Power switch at the top - shows state and controls on/off
    if "power" in entities:
        button_entities.append({
            "entity": entities["power"],
            "name": "Power",
        })
    if "art_mode_button" in entities:
        button_entities.append({
            "entity": entities["art_mode_button"],
            "name": "Art Mode",
        })
    if "on_art_mode" in entities:
        button_entities.append({
            "entity": entities["on_art_mode"],
            "name": "On + Art Mode",
        })
    
    # Brightness level at the bottom
    if "brightness" in entities:
        button_entities.append({
            "entity": entities["brightness"],
            "name": "Brightness Level",
        })

    # Image metadata at bottom of this card
    if "current_artwork" in entities:
        button_entities.append({
            "entity": entities["current_artwork"],
            "name": "Current Image",
        })

    if "matte_filter" in entities:
        button_entities.append({
            "entity": entities["matte_filter"],
            "name": "Matte / Filter",
        })

    if "tags_combined" in entities:
        button_entities.append({
            "entity": entities["tags_combined"],
            "name": "Tags",
        })
    
    if not button_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Power Controls",
        "entities": button_entities,
    }


def _build_artwork_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build artwork section with image on top, controls below.
    
    Structure:
    - Markdown card with title "Artwork" and image
    - Entities card with shuffle button and details combined
    """
    if "current_artwork" not in entities:
        return None
    
    artwork_entity = entities["current_artwork"]
    screen_on_entity = entities.get("screen_on")
    
    cards = []
    
    # Build image template that includes screen off indicator
    if screen_on_entity:
        image_template = f"""{{% if is_state('{screen_on_entity}', 'on') %}}
![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})
{{% else %}}
![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})

<center>***** Screen is off *****</center>
{{% endif %}}"""
    else:
        image_template = f"![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})"
    
    # Image card with title on top
    cards.append({
        "type": "markdown",
        "title": "Artwork",
        "content": image_template,
    })
    
    # Combined controls: shuffle button + details
    control_entities = []
    
    if "auto_shuffle_switch" in entities:
        control_entities.append({
            "entity": entities["auto_shuffle_switch"],
            "name": "Auto Shuffle",
        })

    if "shuffle" in entities:
        control_entities.append({
            "entity": entities["shuffle"],
            "name": "Shuffle Image",
        })

    if "shuffle_frequency" in entities:
        control_entities.append({
            "entity": entities["shuffle_frequency"],
            "name": "Shuffle Frequency",
        })

    if "auto_shuffle_next" in entities:
        control_entities.append({
            "entity": entities["auto_shuffle_next"],
            "name": "Next Auto Shuffle",
        })

    if "last_shuffle_timestamp" in entities:
        control_entities.append({
            "entity": entities["last_shuffle_timestamp"],
            "name": "Last Shuffle",
        })

    if "matching_image_count" in entities:
        control_entities.append({
            "entity": entities["matching_image_count"],
            "name": "Matching Images",
        })
    
    if control_entities:
        cards.append({
            "type": "entities",
            "entities": control_entities,
        })
    
    return {
        "type": "vertical-stack",
        "cards": cards,
    }


def _build_combined_brightness_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build combined brightness section with auto-brightness settings in ONE card."""
    all_entities = []
    
    # Auto-brightness enable/disable switch
    if "dynamic_brightness" in entities:
        all_entities.append({
            "entity": entities["dynamic_brightness"],
            "name": "Auto-Brightness",
        })
    
    # Trigger button
    if "trigger_brightness" in entities:
        all_entities.append({
            "entity": entities["trigger_brightness"],
        })
    
    # Status sensors
    if "auto_bright_sensor_lux" in entities:
        all_entities.append({
            "entity": entities["auto_bright_sensor_lux"],
            "name": "Current Lux",
        })
    
    if "auto_bright_target" in entities:
        all_entities.append({
            "entity": entities["auto_bright_target"],
            "name": "Target Brightness",
        })
    
    if "auto_bright_next" in entities:
        all_entities.append({
            "entity": entities["auto_bright_next"],
            "name": "Next Adjustment",
        })
    
    if "auto_bright_last" in entities:
        all_entities.append({
            "entity": entities["auto_bright_last"],
            "name": "Last Adjustment",
        })
    
    # Configuration entities - add to same list
    if "min_lux" in entities:
        all_entities.append({
            "entity": entities["min_lux"],
            "name": "Min Lux (Dark)",
        })
    
    if "max_lux" in entities:
        all_entities.append({
            "entity": entities["max_lux"],
            "name": "Max Lux (Bright)",
        })
    
    if "min_brightness" in entities:
        all_entities.append({
            "entity": entities["min_brightness"],
            "name": "Min Level",
        })
    
    if "max_brightness" in entities:
        all_entities.append({
            "entity": entities["max_brightness"],
            "name": "Max Level",
        })
    
    # Calibration buttons
    if "calibrate_dark" in entities:
        all_entities.append({
            "entity": entities["calibrate_dark"],
        })
    
    if "calibrate_bright" in entities:
        all_entities.append({
            "entity": entities["calibrate_bright"],
        })
    
    if not all_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Brightness",
        "entities": all_entities,
    }


def _build_auto_motion_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the auto-motion management section."""
    section_entities = []
    
    # Enable/disable switch
    if "motion_control" in entities:
        section_entities.append({
            "entity": entities["motion_control"],
            "name": "Auto-Motion Enable",
        })
    
    # Verbose logging switch (for debugging multi-sensor setups)
    if "verbose_motion_logging" in entities:
        section_entities.append({
            "entity": entities["verbose_motion_logging"],
            "name": "Verbose Logging",
        })
    
    # Trigger off button
    if "trigger_motion_off" in entities:
        section_entities.append({
            "entity": entities["trigger_motion_off"],
        })
    
    # Motion off delay config
    if "motion_off_delay" in entities:
        section_entities.append({
            "entity": entities["motion_off_delay"],
            "name": "Off Delay",
        })
    
    # Status sensors
    if "auto_motion_off_at" in entities:
        section_entities.append({
            "entity": entities["auto_motion_off_at"],
            "name": "Turning Off At",
        })
    
    if "auto_motion_last" in entities:
        section_entities.append({
            "entity": entities["auto_motion_last"],
            "name": "Last Motion",
        })
    
    if not section_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Motion",
        "entities": section_entities,
    }


def _build_activity_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the recent activity section using a markdown card with template.
    
    This creates a markdown card that displays the formatted history from
    the activity sensor's attributes.
    """
    if "recent_activity" not in entities:
        return None
    
    activity_entity = entities["recent_activity"]
    
    # Build a markdown template that renders the history nicely
    # The template iterates over the formatted_history attribute
    template_content = f"""## Recent Activity

{{% set history = state_attr('{activity_entity}', 'formatted_history') or [] %}}
{{% if history | length == 0 %}}
_No activity recorded yet_
{{% else %}}
{{% set ns = namespace(last_day=None) %}}
{{% for event in history %}}
{{% if event.day_header != ns.last_day %}}
**{{{{ event.day_header }}}}**
{{% set ns.last_day = event.day_header %}}
{{% endif %}}
{{{{ event.time_display }}}} - {{{{ event.message }}}}
{{% endfor %}}
{{% endif %}}"""
    
    return {
        "type": "markdown",
        "content": template_content,
    }


async def async_generate_dashboard(hass: Any, entry: Any) -> bool:
    """Async wrapper for dashboard generation.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    from pathlib import Path
    
    # Output path for the dashboard
    output_path = Path(__file__).parent / "dashboards" / "frame_tv_manager.yaml"
    
    # Run the generation in the executor since it does file I/O
    result = await hass.async_add_executor_job(
        generate_dashboard,
        hass,
        entry,
        output_path,
    )
    
    return result
