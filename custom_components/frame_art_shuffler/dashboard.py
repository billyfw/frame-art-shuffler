"""Dashboard generator for Frame Art Shuffler integration.

This module generates a dynamic Lovelace dashboard YAML file based on
registered Frame Art devices and their entities.
"""
from __future__ import annotations

import logging
from pathlib import Path
from typing import Any

import yaml

_LOGGER = logging.getLogger(__name__)

# Header comment for generated dashboard
DASHBOARD_HEADER = """\
# ============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT
# ============================================================================
# This dashboard is automatically generated by the Frame Art Shuffler
# integration. Any manual changes will be overwritten on the next restart.
#
# To customize, create your own dashboard and use these entities as reference.
# ============================================================================

"""


def generate_dashboard(
    hass: Any,
    entry: Any,
    output_path: Path,
) -> bool:
    """Generate the Lovelace dashboard YAML file.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        output_path: Path to write the YAML file
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    try:
        from homeassistant.helpers import device_registry as dr
        from homeassistant.helpers import entity_registry as er
        from .const import DOMAIN
        from .config_entry import list_tv_configs
    except ImportError:
        _LOGGER.error("Cannot generate dashboard: Home Assistant not available")
        return False

    device_registry = dr.async_get(hass)
    entity_registry = er.async_get(hass)

    # Get all TV configs from the entry
    tv_configs = list_tv_configs(entry)
    
    if not tv_configs:
        _LOGGER.info("No TVs configured, skipping dashboard generation")
        return False

    # Build the dashboard structure
    dashboard = _build_dashboard(
        hass,
        entry,
        tv_configs,
        device_registry,
        entity_registry,
    )

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write the YAML file
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(DASHBOARD_HEADER)
            yaml.dump(dashboard, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
        _LOGGER.info(f"Dashboard generated successfully at {output_path}")
        return True
    except OSError as err:
        _LOGGER.error(f"Failed to write dashboard file: {err}")
        return False


def _build_dashboard(
    hass: Any,
    entry: Any,
    tv_configs: dict[str, dict[str, Any]],
    device_registry: Any,
    entity_registry: Any,
) -> dict[str, Any]:
    """Build the complete dashboard configuration.
    
    Each TV gets its own tab (view) in the dashboard.
    """
    from .const import DOMAIN
    
    views = []
    
    # Build a view (tab) for each TV
    for tv_id, tv_config in tv_configs.items():
        tv_name = tv_config.get("name", tv_id)
        view = _build_tv_view(hass, entry, tv_id, tv_name, entity_registry)
        if view:
            views.append(view)
    
    # If no TVs configured, show a placeholder view
    if not views:
        views.append({
            "title": "Frame TV Manager",
            "path": "frame-tv-manager",
            "icon": "mdi:television-ambient-light",
            "cards": [{
                "type": "markdown",
                "content": "No Frame Art TVs configured. Add a TV through the integration settings.",
            }],
        })

    # Build complete dashboard
    dashboard = {
        "title": "Frame TV Manager",
        "views": views,
    }

    return dashboard


def _build_tv_view(
    hass: Any,
    entry: Any,
    tv_id: str,
    tv_name: str,
    entity_registry: Any,
) -> dict[str, Any] | None:
    """Build a view (tab) for a single TV with two-column layout."""
    from .const import DOMAIN
    
    # Find all entities for this TV
    entities = _get_tv_entities(entry.entry_id, tv_id, entity_registry)
    
    if not entities:
        return None

    # === LEFT COLUMN: Status, Artwork, Recent Activity ===
    left_cards = []
    
    # Status Section
    status_card = _build_status_section(entities)
    if status_card:
        left_cards.append(status_card)
    
    # Combined Current Artwork (image + details)
    artwork_card = _build_artwork_section(entities)
    if artwork_card:
        left_cards.append(artwork_card)
    
    # Recent Activity at bottom of left column
    activity_card = _build_activity_section(entities)
    if activity_card:
        left_cards.append(activity_card)
    
    left_column = {
        "type": "vertical-stack",
        "cards": left_cards,
    } if left_cards else None

    # === RIGHT COLUMN: Power Controls, Motion, Brightness ===
    right_cards = []
    
    # Power Controls
    power_card = _build_power_controls_section(entities)
    if power_card:
        right_cards.append(power_card)
    
    # Motion
    auto_motion_card = _build_auto_motion_section(entities)
    if auto_motion_card:
        right_cards.append(auto_motion_card)
    
    # Combined Brightness (manual + auto)
    brightness_card = _build_combined_brightness_section(entities)
    if brightness_card:
        right_cards.append(brightness_card)
    
    right_column = {
        "type": "vertical-stack",
        "cards": right_cards,
    } if right_cards else None

    # Build the two-column grid
    top_row_cards = [c for c in [left_column, right_column] if c]
    
    # Use a vertical-stack to wrap the grid
    all_cards = []
    
    if len(top_row_cards) == 2:
        all_cards.append({
            "type": "grid",
            "columns": 2,
            "square": False,
            "cards": top_row_cards,
        })
    elif top_row_cards:
        all_cards.extend(top_row_cards)

    # Wrap everything in a vertical-stack to enforce top-to-bottom layout
    view_cards = [{
        "type": "vertical-stack",
        "cards": all_cards,
    }] if all_cards else []

    # Create a safe path from TV name
    safe_path = tv_id.lower().replace(" ", "-").replace("_", "-")
    
    return {
        "title": tv_name,
        "path": safe_path,
        "icon": "mdi:television-ambient-light",
        "panel": True,  # Full width layout instead of centered masonry
        "cards": view_cards,
    }


# _build_tv_card removed - replaced by _build_tv_view which creates a full view per TV


def _get_tv_entities(
    entry_id: str,
    tv_id: str,
    entity_registry: Any,
) -> dict[str, str]:
    """Get all entity IDs for a specific TV.
    
    Returns a dict mapping entity key to entity_id.
    """
    from .const import DOMAIN
    
    entities = {}
    
    # Entity unique_id patterns to look for
    patterns = {
        # Binary sensors
        "screen_on": f"{entry_id}_{tv_id}_screen_on",
        "art_mode": f"{entry_id}_{tv_id}_art_mode",
        # Sensors
        "current_artwork": f"{entry_id}_{tv_id}",
        "last_shuffle_image": f"{entry_id}_{tv_id}_last_shuffle_image",
        "last_shuffle_timestamp": f"{entry_id}_{tv_id}_last_shuffle_timestamp",
        "ip_address": f"{entry_id}_{tv_id}_ip",
        "mac_address": f"{entry_id}_{tv_id}_mac",
        "motion_sensor": f"{entry_id}_{tv_id}_motion_sensor",
        "light_sensor": f"{entry_id}_{tv_id}_light_sensor",
        "auto_bright_last": f"{entry_id}_{tv_id}_auto_bright_last",
        "auto_bright_next": f"{entry_id}_{tv_id}_auto_bright_next",
        "auto_bright_target": f"{entry_id}_{tv_id}_auto_bright_target",
        "auto_bright_sensor_lux": f"{entry_id}_{tv_id}_auto_bright_sensor_lux",
        "auto_motion_last": f"{entry_id}_{tv_id}_auto_motion_last",
        "auto_motion_off_at": f"{entry_id}_{tv_id}_auto_motion_off_at",
        "recent_activity": f"{entry_id}_{tv_id}_recent_activity",
        # Numbers
        "shuffle_frequency": f"{tv_id}_shuffle_frequency",
        "brightness": f"{tv_id}_brightness",
        "min_lux": f"{tv_id}_min_lux",
        "max_lux": f"{tv_id}_max_lux",
        "min_brightness": f"{tv_id}_min_auto_brightness",
        "max_brightness": f"{tv_id}_max_auto_brightness",
        "motion_off_delay": f"{tv_id}_motion_off_delay",
        # Switches
        "dynamic_brightness": f"{tv_id}_dynamic_brightness",
        "motion_control": f"{tv_id}_motion_control",
        # Buttons
        "tv_on": f"{tv_id}_tv_on",
        "tv_off": f"{tv_id}_tv_off",
        "art_mode_button": f"{tv_id}_art_mode",
        "on_art_mode": f"{tv_id}_on_art_mode",
        "shuffle": f"{tv_id}_shuffle",
        "clear_token": f"{tv_id}_clear_token",
        "calibrate_dark": f"{tv_id}_calibrate_dark",
        "calibrate_bright": f"{tv_id}_calibrate_bright",
        "trigger_brightness": f"{tv_id}_trigger_brightness",
        "trigger_motion_off": f"{tv_id}_trigger_motion_off",
    }
    
    # Look up each entity
    for key, unique_id in patterns.items():
        entity_entry = entity_registry.async_get_entity_id(
            _get_platform_for_key(key),
            DOMAIN,
            unique_id,
        )
        if entity_entry:
            entities[key] = entity_entry
    
    return entities


def _get_platform_for_key(key: str) -> str:
    """Get the platform (domain) for an entity key."""
    binary_sensors = {"screen_on", "art_mode"}
    sensors = {
        "current_artwork", "last_shuffle_image", "last_shuffle_timestamp",
        "ip_address", "mac_address", "motion_sensor", "light_sensor",
        "auto_bright_last", "auto_bright_next", "auto_bright_target",
        "auto_bright_sensor_lux", "auto_motion_last", "auto_motion_off_at",
        "recent_activity",
    }
    numbers = {
        "shuffle_frequency", "brightness", "min_lux", "max_lux",
        "min_brightness", "max_brightness", "motion_off_delay",
    }
    switches = {"dynamic_brightness", "motion_control"}
    buttons = {
        "tv_on", "tv_off", "art_mode_button", "on_art_mode", "shuffle",
        "clear_token", "calibrate_dark", "calibrate_bright",
        "trigger_brightness", "trigger_motion_off",
    }
    
    if key in binary_sensors:
        return "binary_sensor"
    elif key in sensors:
        return "sensor"
    elif key in numbers:
        return "number"
    elif key in switches:
        return "switch"
    elif key in buttons:
        return "button"
    return "sensor"


def _build_status_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the status section showing on/off and art mode (without power controls)."""
    status_entities = []
    
    # Screen on/off status
    if "screen_on" in entities:
        status_entities.append({
            "entity": entities["screen_on"],
            "name": "Screen",
        })
    
    # Art mode status
    if "art_mode" in entities:
        status_entities.append({
            "entity": entities["art_mode"],
            "name": "Art Mode",
        })
    
    if not status_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Status",
        "entities": status_entities,
    }


def _build_power_controls_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the power controls section."""
    button_entities = []
    if "tv_on" in entities:
        button_entities.append({
            "entity": entities["tv_on"],
            "name": "TV On",
        })
    if "tv_off" in entities:
        button_entities.append({
            "entity": entities["tv_off"],
            "name": "TV Off",
        })
    if "art_mode_button" in entities:
        button_entities.append({
            "entity": entities["art_mode_button"],
            "name": "Art Mode",
        })
    if "on_art_mode" in entities:
        button_entities.append({
            "entity": entities["on_art_mode"],
            "name": "On + Art Mode",
        })
    
    # Brightness level at the bottom
    if "brightness" in entities:
        button_entities.append({
            "entity": entities["brightness"],
            "name": "Brightness Level",
        })
    
    if not button_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Power Controls",
        "entities": button_entities,
    }


def _build_artwork_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build artwork section with image on top, controls below.
    
    Structure:
    - Markdown card with title "Artwork" and image
    - Entities card with shuffle button and details combined
    """
    if "current_artwork" not in entities:
        return None
    
    artwork_entity = entities["current_artwork"]
    screen_on_entity = entities.get("screen_on")
    
    cards = []
    
    # Build image template that includes screen off indicator
    if screen_on_entity:
        image_template = f"""{{% if is_state('{screen_on_entity}', 'on') %}}
![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})
{{% else %}}
![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})

<center>***** Screen is off *****</center>
{{% endif %}}"""
    else:
        image_template = f"![Current Art](/local/frame_art/library/{{{{ states('{artwork_entity}') }}}})"
    
    # Image card with title on top
    cards.append({
        "type": "markdown",
        "title": "Artwork",
        "content": image_template,
    })
    
    # Combined controls: shuffle button + details
    control_entities = []
    
    if "shuffle" in entities:
        control_entities.append({
            "entity": entities["shuffle"],
            "name": "Shuffle Image",
        })
    
    if "current_artwork" in entities:
        control_entities.append({
            "entity": entities["current_artwork"],
            "name": "Current Image",
        })
    
    if "shuffle_frequency" in entities:
        control_entities.append({
            "entity": entities["shuffle_frequency"],
            "name": "Shuffle Frequency",
        })
    
    if "last_shuffle_timestamp" in entities:
        control_entities.append({
            "entity": entities["last_shuffle_timestamp"],
            "name": "Last Shuffle",
        })
    
    if control_entities:
        cards.append({
            "type": "entities",
            "entities": control_entities,
        })
    
    return {
        "type": "vertical-stack",
        "cards": cards,
    }


def _build_combined_brightness_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build combined brightness section with auto-brightness settings in ONE card."""
    all_entities = []
    
    # Auto-brightness enable/disable switch
    if "dynamic_brightness" in entities:
        all_entities.append({
            "entity": entities["dynamic_brightness"],
            "name": "Auto-Brightness",
        })
    
    # Trigger button
    if "trigger_brightness" in entities:
        all_entities.append({
            "entity": entities["trigger_brightness"],
        })
    
    # Status sensors
    if "auto_bright_sensor_lux" in entities:
        all_entities.append({
            "entity": entities["auto_bright_sensor_lux"],
            "name": "Current Lux",
        })
    
    if "auto_bright_target" in entities:
        all_entities.append({
            "entity": entities["auto_bright_target"],
            "name": "Target Brightness",
        })
    
    if "auto_bright_next" in entities:
        all_entities.append({
            "entity": entities["auto_bright_next"],
            "name": "Next Adjustment",
        })
    
    if "auto_bright_last" in entities:
        all_entities.append({
            "entity": entities["auto_bright_last"],
            "name": "Last Adjustment",
        })
    
    # Configuration entities - add to same list
    if "min_lux" in entities:
        all_entities.append({
            "entity": entities["min_lux"],
            "name": "Min Lux (Dark)",
        })
    
    if "max_lux" in entities:
        all_entities.append({
            "entity": entities["max_lux"],
            "name": "Max Lux (Bright)",
        })
    
    if "min_brightness" in entities:
        all_entities.append({
            "entity": entities["min_brightness"],
            "name": "Min Level",
        })
    
    if "max_brightness" in entities:
        all_entities.append({
            "entity": entities["max_brightness"],
            "name": "Max Level",
        })
    
    # Calibration buttons
    if "calibrate_dark" in entities:
        all_entities.append({
            "entity": entities["calibrate_dark"],
        })
    
    if "calibrate_bright" in entities:
        all_entities.append({
            "entity": entities["calibrate_bright"],
        })
    
    if not all_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Brightness",
        "entities": all_entities,
    }


def _build_auto_motion_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the auto-motion management section."""
    section_entities = []
    
    # Enable/disable switch
    if "motion_control" in entities:
        section_entities.append({
            "entity": entities["motion_control"],
            "name": "Auto-Motion Enable",
        })
    
    # Trigger off button
    if "trigger_motion_off" in entities:
        section_entities.append({
            "entity": entities["trigger_motion_off"],
        })
    
    # Motion off delay config
    if "motion_off_delay" in entities:
        section_entities.append({
            "entity": entities["motion_off_delay"],
            "name": "Off Delay",
        })
    
    # Status sensors
    if "auto_motion_off_at" in entities:
        section_entities.append({
            "entity": entities["auto_motion_off_at"],
            "name": "Turning Off At",
        })
    
    if "auto_motion_last" in entities:
        section_entities.append({
            "entity": entities["auto_motion_last"],
            "name": "Last Motion",
        })
    
    # Associated motion sensor
    if "motion_sensor" in entities:
        section_entities.append({
            "entity": entities["motion_sensor"],
            "name": "Motion Sensor",
        })
    
    if not section_entities:
        return None
    
    return {
        "type": "entities",
        "title": "Motion",
        "entities": section_entities,
    }


def _build_activity_section(entities: dict[str, str]) -> dict[str, Any] | None:
    """Build the recent activity section using a markdown card with template.
    
    This creates a markdown card that displays the formatted history from
    the activity sensor's attributes.
    """
    if "recent_activity" not in entities:
        return None
    
    activity_entity = entities["recent_activity"]
    
    # Build a markdown template that renders the history nicely
    # The template iterates over the formatted_history attribute
    template_content = f"""## Recent Activity

{{% set history = state_attr('{activity_entity}', 'formatted_history') or [] %}}
{{% if history | length == 0 %}}
_No activity recorded yet_
{{% else %}}
{{% for event in history[:30] %}}
**{{{{ event.time }}}}** - {{{{ event.message }}}}
{{% endfor %}}
{{% endif %}}"""
    
    return {
        "type": "markdown",
        "content": template_content,
    }


async def async_generate_dashboard(hass: Any, entry: Any) -> bool:
    """Async wrapper for dashboard generation.
    
    Args:
        hass: Home Assistant instance
        entry: Config entry for the integration
        
    Returns:
        True if dashboard was generated successfully, False otherwise
    """
    from pathlib import Path
    
    # Output path for the dashboard
    output_path = Path(__file__).parent / "dashboards" / "frame_tv_manager.yaml"
    
    # Run the generation in the executor since it does file I/O
    result = await hass.async_add_executor_job(
        generate_dashboard,
        hass,
        entry,
        output_path,
    )
    
    return result
