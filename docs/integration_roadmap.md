# Frame Art Shuffler Integration Roadmap

## Context and Guiding Principles
- Home Assistant becomes the single authority for defining Samsung Frame TVs; the add-on consumes `metadata.json` and renders UI.
- Multiple HA instances may coexist. Each instance manages only the TVs tagged with its own **home** value.
- The integration must be installable through HACS, follow HA best practices (config flows, async boundaries, service wrappers), and coordinate cleanly with the add-on.
- The add-on will remove TV CRUD screens, accept update notifications from the integration, and respect the shared `home` identifier when rendering data.

## Metadata Schema Updates
- Extend `metadata.json` with a top-level `homes` registry used to prevent duplicate claims:
  ```json
  "homes": {
    "Madrone": {
      "instance_id": "c8d4f0b5-a0b3-4a25-8135-1e7f7cf27c8f",
      "friendly_name": "Madrone"
    }
  }
  ```
- `instance_id` is a UUID generated by the integration (persisted in the config entry). `friendly_name` mirrors the home string for clarity and can hold a user-facing label later.
- Claim rules:
  1. During config flow, read `homes`. If `home` is absent, write `{instance_id, friendly_name}`.
  2. If `home` exists with a different `instance_id`, abort with an error (“Home already claimed by another integration instance”).
  3. If `home` exists with the same `instance_id`, continue (allows reconfiguration).
- Provide helpers `claim_home(home, instance_id)` and `release_home(home, instance_id)` inside the integration. Releasing can be added later; note it as a backlog item.

## Phase 1 – HACS-Ready Integration Foundation
**Goal:** deliver a minimal integration that installs via HACS, claims a unique home, pairs TVs, and writes scoped entries to `metadata.json`.

Key tasks:
1. **Packaging**
   - Add `hacs.json` and ensure `manifest.json` metadata (version, documentation, codeowners) is correct.
   - Update README with HACS installation instructions.
   - Prepare initial tagged release once functionality is verified.

2. **Config flow & reauth**
   - Step 1: request integration-level `home` string; perform home-claim guard using the `homes` registry.
   - Step 2: select existing TV (matching home) or create new; gather TV name, IP/hostname (IPv4, IPv6, mDNS allowed), MAC (normalized using add-on logic), tags, exclude tags, shuffle frequency (minutes).
   - Step 3: run Samsung pairing handshake; store token under `/config/frame_art_tokens/<safe_ip>.token`.
   - Persist TV data (with `home`) to `metadata.json` via metadata helper.
   - Implement reauth flow that re-runs pairing when tokens fail.

3. **Metadata helper module**
   - Read/write `metadata.json` atomically (temp file + rename) under a shared lock.
   - Filter `tvs` by `home` when presenting data to HA.
   - Upsert TVs (ensure IDs are stable UUIDs), normalize tags/notTags arrays, and auto-add new tags to the global tag list.
   - Manage the `homes` registry and expose claim helpers.

4. **Entity scaffolding**
   - Create a basic per-TV entity (e.g., `FrameArtTVEntity` derived from `CoordinatorEntity`) exposing static attributes (name, IP, MAC, tags) so we can verify the integration registers devices/entities.
   - No control services yet—focus on state reflection and metadata persistence.

5. **Stubbed add-on notification**
   - Implement `notify_addon_tv_change(payload)` that logs a TODO; wire it where TVs are created/updated/deleted so drop-in replacement later is trivial.

6. **Validation & tests**
   - Unit tests for metadata helper (home claim collisions, TV upsert, tag normalization).
   - Tests for config flow validation (invalid IP/MAC scenarios, home conflict, pairing handshake mocked).
   - Manual test script: add integration, create TV, inspect `metadata.json`, edit TV via options flow, confirm filtering by home.

Deliverables: updated docs, working integration installable via HACS, passing tests, clear TODOs for Phase 2/3 integration points.

## Phase 2 – Add-on Alignment (external work)
**Goal:** update `ha-frame-art-manager` so it cooperates with the new integration-driven workflow.

Required changes:
1. Remove TV creation/edit UI from the “Advanced” area and delete associated REST endpoints (retain `GET /api/tvs` for read-only data).
2. Add a configuration option for `home`; filter TVs and tags displayed in the add-on to those matching that value.
3. Implement update callback endpoint:
   - **Endpoint:** `POST /api/tvs/sync`
   - **Headers:** `Content-Type: application/json`
   - **Body:**
     ```json
     {
       "event": "created" | "updated" | "deleted",
       "home": "Madrone",
       "tv": { ...full TV object exactly as stored in metadata... }
     }
     ```
   - On receipt: verify `home` matches the configured value, refresh caches/UI, return `200 {"success": true}`. Ignore mismatched homes.
4. (Optional) Watch `metadata.json` for changes to catch manual edits or future automation.
5. Update add-on docs and UI copy to point users to Home Assistant for TV pairing.

## Phase 3 – Control Surface Expansion
**Goal:** make the integration an effective controller for each TV.

Tasks:
- Introduce a DataUpdateCoordinator that polls/refreshes per-TV state (current image, last shuffle time, connectivity flags) and continues to respect the `home` filter.
- Expand entities:
  - `MediaPlayerEntity` (or custom entity) per TV for art mode on/off with state attributes.
  - Editable helper entities: `Number` for shuffle frequency, `Text` for IP/MAC, `Select` or `Text` for include/exclude tags. Editing writes back to metadata and calls the add-on endpoint.
  - Button entities triggering key actions (shuffle now, power on/off, refresh metadata, set brightness max).
- Wrap `frame_tv.py` helper calls via `hass.async_add_executor_job`; ensure executor use is centralized to simplify testing.
- Debounce metadata writes (e.g., lock + minimal delay) to prevent multiple quick edits from fighting each other.
- Add tests for service handlers, entity state updates, and metadata persistence when helper entities change.
- Documentation updates covering the new device controls.

## Phase 4 – Full-System Automation
**Goal:** complete the art-shuffle loop with automation hooks and logging.

Tasks:
- Implement random image selection based on tags/exclude tags and integrate with `set_art_on_tv_delete_others`.
- Add structured logging (`/config/frame_art/log.json`) capturing image displays (TV, image, timestamps). Consider emitting HA events like `frame_art_shuffler.image_displayed` for native automations.
- Listen for add-on scheduling events (e.g., `frame_art_manager.shuffle_due`) and provide example HA automations linking events to services.
- Improve error handling: persistent notifications or Repairs entries when token pairing fails or TVs are unreachable; log to both HA and JSON log.
- Finalize documentation with end-to-end usage examples, automations, and troubleshooting.
- Expand test coverage (integration tests if possible) for shuffle flow, logging, and event handling.

## Add-on Work Checklist (for reference)
- [ ] Remove TV CRUD UI/routes; keep `GET /api/tvs` read-only.
- [ ] Introduce `home` setting and filter data accordingly.
- [ ] Implement `POST /api/tvs/sync` endpoint as specified.
- [ ] Optionally watch `metadata.json` for changes.
- [ ] Update documentation/UI language to reflect HA-managed TVs.

## Cross-Cutting Tasks and Backlog
- Maintain semantic versioning and changelog entries for each phase; cut new releases as capabilities land.
- Set up CI (lint, pytest) before publishing to HACS; ensure tests cover metadata helpers and config flow paths.
- Document migration steps for users moving from add-on managed TVs to the integration.
- Backlog ideas: home-claim cleanup service, orphan detection, more granular file watchers, richer UI dashboards, automated log rotation.

## Tracking Status
Use the chapters above as checkpoints. Before moving to the next phase, ensure all tasks in the current phase are complete, tests are green, documentation is updated, and (where relevant) a release is tagged. Add notes directly to this file as progress is made.
